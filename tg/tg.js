let telegram = require('telegram-bot-api'),
    api = new telegram({
        token: "306033696:AAGa7u-AaiYawaEBBlu8gfEl_lYpi7GHfkg",
        polling: true,
        updates: {
            enabled: true,
            get_interval: 500
        }
    }),
    bodyParser = require('body-parser'),
    express = require("express"),
    app = express(),
    winston = require('winston'),
    logger = new (winston.Logger)({
        transports: [
            new (winston.transports.Console)(),
            new winston.transports.File({filename: __dirname + '/tg_debug.log', json: true})
        ],
        exceptionHandlers: [
            new (winston.transports.Console)(),
            new winston.transports.File({filename: __dirname + '/tg_exceptions.log', json: true})
        ],
        exitOnError: false
    }),
    http = require('http'),
    ApiCaller = require('./APICaller'),
    DBCaller = require('./DBCaller'),
    dbCaller = new DBCaller(),
    KeyboardBuilder = require('./KeyboardBuilder.js'),
    telegraph = require('telegraph-node'),
    ph = new telegraph(),
    telegraph_token = '6aa707fb088b6efb50762cfba746414a345025f53cb280f0678b83e9eb59',
    restler = require('restler'),
    moment = require('moment'),
    smtpTransport = require('nodemailer-smtp-transport'),
    nodemailer = require('nodemailer'),
    fs = require('fs'),
    config = JSON.parse(fs.readFileSync('../v1-config.json'));

let config_index = process.env.ENV ? process.env.ENV : 'local',
    real_config = config[config_index],
    transporter = nodemailer.createTransport(smtpTransport({
        host: real_config.smtp.host,
        port: real_config.smtp.port,
        secure: false,
        auth: {
            user: real_config.smtp.user,
            pass: real_config.smtp.password
        }
    }));

api.getMe()
    .then(function (data) {
        console.log(data);
        ph.createAccount('Evendate bot', {short_name: 'Evendate bot', author_name: 'Evendate bot'}).then((result) => {
            console.log(result)
        })
    })
    .catch(function (err) {
        console.log(err);
    });

const TOPIC_ICONS = {
    '–û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ': 'üéì –û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ',
    '–ö—É–ª—å—Ç—É—Ä–∞ –∏ –∏—Å–∫—É—Å—Å—Ç–≤–æ': 'üé≠ –ö—É–ª—å—Ç—É—Ä–∞ –∏ –∏—Å–∫—É—Å—Å—Ç–≤–æ',
    '–†–∞–∑–≤–ª–µ—á–µ–Ω–∏—è': 'üéâ –†–∞–∑–≤–ª–µ—á–µ–Ω–∏—è',
    '–¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏': 'üñ• –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏',
    '–ü—Ä–∏—Ä–æ–¥–∞': 'üê£ –ü—Ä–∏—Ä–æ–¥–∞',
    '–î–∏–∑–∞–π–Ω': 'üé® –î–∏–∑–∞–π–Ω',
    '–ë–∏–∑–Ω–µ—Å': 'üëî –ë–∏–∑–Ω–µ—Å',
    '–î–µ–Ω—å–≥–∏': 'üíµ –î–µ–Ω—å–≥–∏',
    '–°–ø–æ—Ä—Ç': '‚õπ –°–ø–æ—Ä—Ç',
    '–ó–¥–æ—Ä–æ–≤—å–µ': 'üèä –ó–¥–æ—Ä–æ–≤—å–µ',
    '–í—ã—Å—Ç–∞–≤–æ—á–Ω—ã–µ –∑–∞–ª—ã': 'üè´ –í—ã—Å—Ç–∞–≤–æ—á–Ω—ã–µ –∑–∞–ª—ã',
    '–û–±—â–µ—Å—Ç–≤–æ': 'üë• –û–±—â–µ—Å—Ç–≤–æ',
    '–í—Å—Ç—Ä–µ—á–∏': 'üèÉ –í—Å—Ç—Ä–µ—á–∏',
    '–ü—É–±–ª–∏—á–Ω—ã–µ –≤—ã—Å—Ç—É–ø–ª–µ–Ω–∏—è': 'üó£ –ü—É–±–ª–∏—á–Ω—ã–µ –≤—ã—Å—Ç—É–ø–ª–µ–Ω–∏—è',
    '–û—Ç–Ω–æ—à–µ–Ω–∏—è': 'üíë –û—Ç–Ω–æ—à–µ–Ω–∏—è'
};

const STATE_KEYS = {
    MENU: '‚¨ÖÔ∏è –ú–µ–Ω—é',
    START: '/start',
    SUBS: "üì´ –ü–æ–¥–ø–∏—Å–∫–∏",
    TOPICS: "üìã –¢–µ–º—ã",
    ORGANIZATIONS: "üèõ –û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏",
    SEARCH: "üîç –ü–æ–∏—Å–∫",
    RECOMMENDATIONS: "üöÄ –î–∞–π —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏",
    ABOUT: "‚ÑπÔ∏è –û –±–æ—Ç–µ",
    FAQ: "‚ùî FAQ",
    FAQ_COMMAND: "/faq",
    SETTINGS: "‚öô –ù–∞—Å—Ç—Ä–æ–π–∫–∏",
    WRITE_TO_DEVELOPERS: "üñä –ù–∞–ø–∏—Å–∞—Ç—å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º",
    RECOMMENDATIONS_TODAY: "üìÖ –°–µ–≥–æ–¥–Ω—è",
    RECOMMENDATIONS_TOMORROW: "üîú –ó–∞–≤—Ç—Ä–∞",
    RECOMMENDATIONS_WEEKEND: "üóì –ù–∞ –≤—ã—Ö–æ–¥–Ω—ã—Ö",
    RECOMMENDATIONS_INTERESTING: "‚≠êÔ∏è –ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ–µ",
    RECOMMENDATIONS_NEAR_5KM: "üõ∞Ô∏è –°–æ–±—ã—Ç–∏—è –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏ (–¥–æ 5 –∫–º)",
    RECOMMENDATIONS_FREE: "üí∏ –ë–µ—Å–ø–ª–∞—Ç–Ω–æ",

};

const STATES = {
    '/start': 'start',
    "üì´ –ü–æ–¥–ø–∏—Å–∫–∏": 'subscriptions',
    "üîç –ü–æ–∏—Å–∫": 'search',
    "üöÄ –î–∞–π —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏": 'recommendations',
    "‚ÑπÔ∏è –û –±–æ—Ç–µ": 'about',
    "‚ùî FAQ": 'faq',
    "‚öô –ù–∞—Å—Ç—Ä–æ–π–∫–∏": 'settings',
    "üñä –ù–∞–ø–∏—Å–∞—Ç—å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º": 'write_to_developers',
    "üìÖ –°–µ–≥–æ–¥–Ω—è": 'recommendations_today',
    "üîú –ó–∞–≤—Ç—Ä–∞": 'recommendations_tomorrow',
    "üóì –ù–∞ –≤—ã—Ö–æ–¥–Ω—ã—Ö": 'recommendations_weekend',
    "‚≠êÔ∏è –ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ–µ": 'recommendations_interesting',
    "üìçÔ∏è –°–æ–±—ã—Ç–∏—è –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏ (–¥–æ 1 –∫–º)": 'recommendations_nearby_1_km',
    "üí∏ –ë–µ—Å–ø–ª–∞—Ç–Ω–æ": 'recommendations_free',
    "üõ∞Ô∏è –°–æ–±—ã—Ç–∏—è –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏ (–¥–æ 5 –∫–º)": 'recommendations_nearby_5_km',
};

let users = {};
const start_keyboard = {
    "keyboard": [
        [STATE_KEYS.SUBS, STATE_KEYS.SEARCH],
        [STATE_KEYS.RECOMMENDATIONS],
        [STATE_KEYS.ABOUT, STATE_KEYS.FAQ],
        [STATE_KEYS.WRITE_TO_DEVELOPERS]
    ],
    "one_time_keyboard": true,
    "resize_keyboard": true
};

let startFromMenu = (chat_id, correct_cmd) => {
    let message_text = '';
    if (!correct_cmd) {
        message_text = '–ù–µ–≤–µ—Ä–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. ';
    }
    api.sendMessage({
        chat_id: chat_id,
        text: message_text + '–î–∞–≤–∞–π—Ç–µ –Ω–∞—á–Ω–µ–º —Å –º–µ–Ω—é.',
        reply_markup: JSON.stringify(start_keyboard)
    })
        .then((result) => {
            console.log(result)
        })
        .catch((err) => {
            console.log(err)
        });
};

let createTelegraphPage = (events, title) => {
    let content = [];
    events.forEach((value, index) => {
        let dates_text = '';

        if (value.first_event_date == value.last_event_date) {
            dates_text = moment.unix(value.first_event_date).format('DD.MM.YYYY');
        } else {
            dates_text = moment.unix(value.first_event_date).format('DD.MM.YYYY') + ' - ' + moment.unix(value.last_event_date).format('DD.MM.YYYY');
        }

        content.push({tag: 'hr'});
        content.push({tag: 'h3', children: [value.title]});
        content.push({tag: 'br'});
        content.push({tag: 'img', attrs: {src: value.image_horizontal_url}});
        content.push({tag: 'p', children: ['–û—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä: ' + value.organization_short_name]});
        content.push({tag: 'p', children: ['–î–∞—Ç—ã: ' + dates_text]});
        content.push({tag: 'br'});
        content.push({tag: 'br'});
        content.push({tag: 'p', children: [value.description]});
        content.push({tag: 'a', attrs: {href: value.link}, children: ['–ü–æ–¥—Ä–æ–±–Ω–µ–µ']});
        content.push({tag: 'hr'});
    });
    return ph.createPage(telegraph_token, title, content, {
        return_content: true
    });
};

api.on('message', function (message) {

    if (!message) return;
    dbCaller.saveChat(message.chat);
    dbCaller.saveMessage(message);
    dbCaller.saveUser(message.from);

    if (message == undefined) return;

    let user_key = '_' + message.from.id;
    let current_state = '/start';

    if (users[user_key] == undefined) {
        users[user_key] = {
            user: message.from,
            states: [STATE_KEYS.START],
            search_results: [],
            search: {
                reply_markup: {}
            },
            recommendations: []
        };
    } else {
        current_state = users[user_key].states[users[user_key].states.length - 1];
    }

    // WITH STATE
    if (message.text != STATE_KEYS.START && message.text != STATE_KEYS.MENU) {
        switch (current_state) {
            case STATE_KEYS.SEARCH: {
                ApiCaller
                    .getEvents({
                        future: 'true',
                        q: message.text,
                        length: 15,
                        offset: 0,
                        fields: 'description,link,organization_short_name'
                    })
                    .then(res => {

                        users[user_key].search_results = res.data;

                        if (res.data.length == 0) {
                            api.sendMessage({
                                chat_id: message.chat.id,
                                text: '–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.'
                            })
                                .catch((err) => {
                                    console.log(err)
                                });
                            return true;
                        }
                        let _event = res.data[0],
                            buttons = [];
                        res.data.forEach((value, index) => {

                            if (index < 5) {

                                let showing_emoji = index == 0 ? '‚úÖ ' : '';

                                buttons.push({
                                    text: showing_emoji + ' ' + String(index + 1),
                                    callback_data: 'show_search_event.' + index
                                });

                            }
                        });

                        createTelegraphPage(res.data, '–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –ø–æ –∑–∞–ø—Ä–æ—Å—É: ' + message.text)
                            .then((result) => {

                                users[user_key].search.reply_markup = {
                                    inline_keyboard: [
                                        [
                                            {
                                                text: '–ü–æ–¥—Ä–æ–±–Ω–µ–µ',
                                                url: _event.link
                                            }
                                        ],
                                        buttons,
                                        [
                                            {
                                                text: '–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ ' + res.data.length + ' —Å–æ–±—ã—Ç–∏–π',
                                                url: result.url
                                            }
                                        ]
                                    ]
                                };

                                api.sendPhoto({
                                    chat_id: message.chat.id,
                                    caption: _event.title + ' \n \n ' + _event.description,
                                    photo: _event.image_horizontal_url,
                                    reply_markup: JSON.stringify(users[user_key].search.reply_markup)
                                })
                                    .then((result) => {
                                    })
                                    .catch((err) => {
                                        console.log(err)
                                    });
                            });
                    })
                    .catch(err => {
                        console.log('ERROR', err);
                    });
                return;
            }
            case STATE_KEYS.SUBS: {
                let keyword = '',
                    is_topic = false;
                for (let topic_key in TOPIC_ICONS) {
                    if (TOPIC_ICONS.hasOwnProperty(topic_key)) {
                        if (TOPIC_ICONS[topic_key] == message.text) {
                            is_topic = true;
                            keyword = topic_key;
                        }
                    }
                }
                if (!is_topic) break;
                dbCaller.getTopicTags(keyword)
                    .then(res => {
                        let message_text;
                        if (res.length == 1) {
                            message_text = res[0].keyword;
                        } else {
                            message_text = [];
                            res.forEach(row => {
                                if (row.is_tags == false) {
                                    message_text.push(row.keyword);
                                }
                            });
                            message_text = message_text.join(', ');
                        }
                        dbCaller.getIsSubscribed(message.chat.id, keyword)
                            .then(is_subscribed => {
                                let keyboard = {
                                    inline_keyboard: [
                                        [
                                            {
                                                text: is_subscribed ? '–û—Ç–ø–∏—Å–∞—Ç—å—Å—è' : '–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è',
                                                callback_data: is_subscribed ? 'unsubscribe.' + keyword : 'subscribe.' + keyword
                                            },
                                            {
                                                text: KeyboardBuilder.getBackButtonText(),
                                                callback_data: 'go_to_menu'
                                            }
                                        ]
                                    ]
                                };
                                api.sendMessage({
                                    chat_id: message.chat.id,
                                    text: '–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —ç—Ç—É —Ç–µ–º—É –ø–æ–∑–≤–æ–ª–∏—Ç –ø–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å–æ–±—ã—Ç–∏—è—Ö –ø–æ —Ç–∞–∫–∏–º —Ç–µ–º–∞—Ç–∏–∫–∞–º –∫–∞–∫: ' + message_text,
                                    reply_markup: JSON.stringify(keyboard)
                                })
                                    .catch((err) => {
                                        console.log(err)
                                    });

                            })
                            .catch((err) => {
                                console.log(err)
                            });

                    })
                    .catch((err) => {
                        console.log(err)
                    });
                return;
            }
            case STATE_KEYS.WRITE_TO_DEVELOPERS: {
                let html = '';
                let letter = message.from;
                letter.__text = message.text;
                for (let i in letter) {
                    if (letter.hasOwnProperty(i)) {
                        html += '<p><strong>' + i + ':</strong> ' + letter[i] + '</p>';
                    }
                }
                transporter.sendMail({
                    debug: true,
                    connectionTimeout: 50000,
                    greetingTimeout: 50000,
                    socketTimeout: 50000,
                    from: 'feedback@evendate.ru',
                    to: 'support@evendate.ru',
                    subject: '–û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å!',
                    html: html
                }, function (err, info) {
                    if (err) {
                        console.log(err);
                    }
                });
                api.sendMessage({
                    chat_id: message.chat.id,
                    text: '–°–ø–∞—Å–∏–±–æ –∑–∞ –í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ! –ú—ã –ø–æ—Å—Ç–∞—Ä–∞–µ–º—Å—è –í–∞–º –æ—Ç–≤–µ—Ç–∏—Ç—å –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ!',
                    reply_markup: JSON.stringify(start_keyboard)
                })
                    .then((result) => {
                        console.log(result)
                    })
                    .catch((err) => {
                        console.log(err)
                    });
                users[user_key].states.push(STATE_KEYS.START);
                return;
            }
        }
    }

    //WITHOUT STATE

    switch (message.text) {
        case STATE_KEYS.MENU:
        case STATE_KEYS.START: {
            api.sendMessage({
                chat_id: message.chat.id,
                text: '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, —Ç–æ–≤–∞—Ä–∏—â!',
                reply_markup: JSON.stringify(start_keyboard)
            })
                .catch((err) => {
                    console.log(err)
                });
            users[user_key].states = [STATE_KEYS.START];
            break;
        }
        case STATE_KEYS.SEARCH: {
            api.sendMessage({
                chat_id: message.chat.id,
                text: '–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞, –ø–æ –∫–æ—Ç–æ—Ä—ã–º –∏—Å–∫–∞—Ç—å —Å–æ–±—ã—Ç–∏—è',
                reply_markup: KeyboardBuilder.getMarkup()
            })
                .catch((err) => {
                    console.log(err)
                });
            users[user_key].states.push(STATE_KEYS.SEARCH);
            break;
        }
        case undefined:
        case STATE_KEYS.RECOMMENDATIONS_TOMORROW:
        case STATE_KEYS.RECOMMENDATIONS_WEEKEND:
        case STATE_KEYS.RECOMMENDATIONS_INTERESTING:
        case STATE_KEYS.RECOMMENDATIONS_TODAY:
        case STATE_KEYS.RECOMMENDATIONS_FREE: {

            if (message.text == undefined && !message.location) {
                return;
            }

            let filters = {
                    future: true,
                    fields: 'actuality,description,link,organization_short_name,nearest_event_date',
                    order_by: '-actuality',
                    length: 20
                },
                recommendation_key = STATES[message.text];

            switch (message.text) {
                case STATE_KEYS.RECOMMENDATIONS_INTERESTING: {
                    filters.fields += ',favored_users_count';
                    filters.order_by = '-favored_users_count';
                    break;
                }
                case STATE_KEYS.RECOMMENDATIONS_WEEKEND: {
                    let _day = moment();
                    while (_day.isoWeekday() != 6 && _day.isoWeekday() != 7) {
                        _day.add(1, 'days');
                    }
                    filters.since = _day.format('YYYY-MM-DD 00:00:01');
                    if (_day.isoWeekday() == 6) {
                        _day.add(1, 'days');
                    }
                    filters.till = _day.format('YYYY-MM-DD 23:59:59');
                    filters.order_by += ',-favored_users_count';

                    break;
                }
                case STATE_KEYS.RECOMMENDATIONS_TODAY: {
                    filters.date = moment().format('YYYY-MM-DD');
                    break;
                }
                case STATE_KEYS.RECOMMENDATIONS_FREE: {
                    filters.is_free = true;
                    break;
                }
                case undefined: {
                    filters.point = message.location.latitude + ' ' + message.location.longitude;
                    filters.distance = 5000;
                    break;
                }
            }

            ApiCaller.getEvents(filters)
                .then((res) => {

                    users[user_key].recommendations[recommendation_key] = {
                        reply_markup: [],
                        results: res.data
                    };

                    if (res.data.length == 0) {
                        api.sendMessage({
                            chat_id: message.chat.id,
                            text: '–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.'
                        })
                            .catch((err) => {
                                console.log(err)
                            });
                        return;
                    }
                    let _event = res.data[0],
                        buttons = [];
                    res.data.forEach((value, index) => {
                        if (index < 5) {
                            let showing_emoji = index == 0 ? '‚úÖ ' : '';
                            buttons.push({
                                text: showing_emoji + ' ' + String(index + 1),
                                callback_data: recommendation_key + '.' + index
                            });

                        }
                    });

                    createTelegraphPage(res.data, '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏: ' + message.text)
                        .then((result) => {
                            users[user_key].recommendations[recommendation_key].reply_markup = {
                                inline_keyboard: [
                                    [
                                        {
                                            text: '–ü–æ–¥—Ä–æ–±–Ω–µ–µ',
                                            url: _event.link
                                        }
                                    ],
                                    buttons,
                                    [
                                        {
                                            text: '–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ ' + res.data.length + ' —Å–æ–±—ã—Ç–∏–π',
                                            url: result.url
                                        }
                                    ]
                                ]
                            };

                            console.log(JSON.stringify(users[user_key].recommendations[recommendation_key].reply_markup));

                            api.sendPhoto({
                                chat_id: message.chat.id,
                                caption: _event.title + ' \n \n ' + _event.description,
                                photo: _event.image_horizontal_url,
                                reply_markup: JSON.stringify(users[user_key].recommendations[recommendation_key].reply_markup)
                            })
                                .then((result) => {
                                })
                                .catch((err) => {
                                    console.log(err)
                                });
                        });
                });

            api.sendMessage({
                chat_id: message.chat.id,
                text: '–°–µ–π—á–∞—Å –ø–æ–¥–±–µ—Ä–µ–º —Å–∞–º—ã–µ –ª—É—á—à–∏–µ —Å–æ–±—ã—Ç–∏—è'
            })
                .then((result) => {
                })
                .catch((err) => {
                    console.log(err)
                });

            break;
        }
        case STATE_KEYS.RECOMMENDATIONS: {
            users[user_key].states.push(STATE_KEYS.RECOMMENDATIONS);

            let keyboard = [
                [STATE_KEYS.RECOMMENDATIONS_TODAY],
                [STATE_KEYS.RECOMMENDATIONS_TOMORROW],
                [STATE_KEYS.RECOMMENDATIONS_WEEKEND],
                [STATE_KEYS.RECOMMENDATIONS_INTERESTING],
                [STATE_KEYS.RECOMMENDATIONS_FREE]];

            if (!message.chat.type || message.chat.type != 'group') {
                keyboard.push([{text: STATE_KEYS.RECOMMENDATIONS_NEAR_5KM, request_location: true}]);
            }

            api.sendMessage({
                chat_id: message.chat.id,
                text: '–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–∫–æ–≥–æ —Ç–∏–ø–∞ –í–∞–º —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏—è',
                reply_markup: KeyboardBuilder.getMarkup(keyboard
                )
            })
                .then((result) => {
                })
                .catch((err) => {
                    console.log(err)
                });
            return;
        }
        case STATE_KEYS.SUBS: {
            users[user_key].states.push(STATE_KEYS.SUBS);

            let buttons = [];
            dbCaller.getSubTopics(message.chat.id)
                .then(sub_rows => {
                    let message_text = '–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–∫–æ–≥–æ —Ç–∏–ø–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –í—ã —Ö–æ—Ç–∏—Ç–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å. ';
                    if (sub_rows.length > 0) {
                        message_text += '–¢–µ–∫—É—â–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏: ';
                        sub_rows.forEach(sub_row => {
                            message_text += '\n ‚úîÔ∏è ' + sub_row.keyword;
                        });
                    } else {
                        message_text += '–°–µ–π—á–∞—Å –ø–æ–¥–ø–∏—Å–æ–∫ –Ω–µ—Ç';
                    }

                    dbCaller.getTopics()
                        .then(rows => {
                            rows.forEach(row => {
                                buttons.push([TOPIC_ICONS[row.keyword]]);
                            });
                            api.sendMessage({
                                chat_id: message.chat.id,
                                text: message_text,
                                reply_markup: KeyboardBuilder.getMarkup(buttons)
                            })
                                .then((result) => {
                                })
                                .catch((err) => {
                                    console.log(err)
                                });
                        })
                        .catch((err) => {
                            console.log(err)
                        });
                })
                .catch((err) => {
                    console.log(err)
                });

            return;
        }
        case STATE_KEYS.WRITE_TO_DEVELOPERS: {
            users[user_key].states.push(STATE_KEYS.WRITE_TO_DEVELOPERS);

            api.sendMessage({
                chat_id: message.chat.id,
                text: '–ù–∞–ø–∏—à–∏—Ç–µ –í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –º—ã –µ–≥–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ–ª—É—á–∏–º –∏ –ø–æ—Å—Ç–∞—Ä–∞–µ–º—Å—è –í–∞–º –æ—Ç–≤–µ—Ç–∏—Ç—å –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ',
                reply_markup: KeyboardBuilder.getMarkup()
            })
                .then((result) => {
                })
                .catch((err) => {
                    console.log(err)
                });
            return;
        }
        case STATE_KEYS.ABOUT: {
            api.sendMessage({
                chat_id: message.chat.id,
                text: '–ë–æ—Ç —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω –∫–æ–º–∞–Ω–¥–æ–π Evendate.\n\n' +
                'EvendateBot –ø–æ–º–æ–∂–µ—Ç –Ω–µ –ø—Ä–æ–ø—É—Å–∫–∞—Ç—å –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è. –ó–∞ –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π –ø–æ —Ä–∞–±–æ—Ç–µ –Ω–∞–∂–º–∏—Ç–µ –Ω–∞–∂–º–∏—Ç–µ /faq. \n\n' +
                'https://evendate.io'
            })
                .catch((err) => {
                    console.log(err)
                });
            return;
        }
        case STATE_KEYS.FAQ_COMMAND:
        case STATE_KEYS.FAQ: {
            api.sendMessage({
                chat_id: message.chat.id,
                text: '–ú—ã —Å–æ–±—Ä–∞–ª–∏ –æ—Ç–≤–µ—Ç—ã –Ω–∞ —á–∞—Å—Ç–æ –∑–∞–¥–∞–≤–∞–µ–º—ã–µ –≤–æ–ø—Ä–æ—Å—ã –Ω–∞ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ: ' +
                'http://telegra.ph/FAQ-po-rabote-s-EvendateBot-02-26' +
                '\n\n –ï—Å–ª–∏ —É –í–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∏ –≤–æ–ø—Ä–æ—Å—ã, –Ω–∞–ø–∏—à–∏—Ç–µ –Ω–∞–º',
                reply_markup: KeyboardBuilder.getMarkup(
                    [
                        [STATE_KEYS.WRITE_TO_DEVELOPERS]
                    ]
                )

            })
                .catch((err) => {
                    console.log(err)
                });
            return;
        }
        default: {
            api.sendMessage({
                chat_id: message.chat.id,
                text: '–Ø –Ω–µ –∑–Ω–∞—é —á—Ç–æ –¥–µ–ª–∞—Ç—å =( –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å —Å–Ω–∞—á–∞–ª–∞',
                reply_markup: KeyboardBuilder.getMarkup()
            })
                .catch((err) => {
                    console.log(err)
                });
            return
        }
    }
});


api.on('inline.callback.query', function (msg) {

    console.log(msg);
    let data = msg.data; //Value from 'callback_data' field of clicked button

    if (msg == undefined) return;

    let user_key = '_' + msg.from.id;
    if (users[user_key] == undefined) return startFromMenu(msg.message.chat.id);


    let command = data.split('.');
    switch (command[0]) {
        case 'show_search_event': {
            if (!users[user_key].search.reply_markup.inline_keyboard
                || users[user_key].search.reply_markup.inline_keyboard.length == 0
                || users[user_key].search_results.length < command[1]) {
                return startFromMenu(msg.message.chat.id);
            }
            users[user_key].search.reply_markup.inline_keyboard[0][0].url = _event.url;
            users[user_key].search.reply_markup.inline_keyboard[1].forEach((value, index) => {

                let showing_emoji = index == command[1] ? '‚úÖ ' : '';

                users[user_key].search.reply_markup.inline_keyboard[1][index].text = showing_emoji + ' ' + String(index + 1);
            });

            let _event = users[user_key].search_results[command[1]];
            console.log(_event);
            api.sendPhoto({
                chat_id: msg.message.chat.id,
                caption: _event.title + ' \n \n ' + _event.description,
                photo: _event.image_horizontal_url,
                reply_markup: JSON.stringify(users[user_key].search.reply_markup)
            })
                .then((result) => {
                    console.log(result)
                })
                .catch((err) => {
                    console.log(err)
                });
            break;
        }
        case 'go_to_menu': {
            startFromMenu(msg.message.chat.id, true);
            break;
        }
        case 'unsubscribe': {
            dbCaller.setSubscriptionStatus(msg.message.chat.id, command[1], false)
                .then(res => {
                    api.editMessageReplyMarkup({
                        chat_id: msg.message.chat.id,
                        message_id: msg.message.message_id,
                        reply_markup: JSON.stringify({
                            inline_keyboard: [
                                [
                                    {
                                        text: '–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è',
                                        callback_data: 'subscribe.' + command[1]
                                    },
                                    {
                                        text: KeyboardBuilder.getBackButtonText(),
                                        callback_data: 'go_to_menu'
                                    }
                                ]
                            ]
                        })
                    })
                        .then((result) => {
                            console.log(result)
                        })
                        .catch((err) => {
                            console.log(err)
                        });
                    api.sendMessage({
                        chat_id: msg.message.chat.id,
                        text: '–í—ã –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç —Ç–µ–º—ã ' + command[1]
                    });

                })
                .catch((err) => {
                    console.log(err)
                });

            break;
        }
        case 'subscribe': {
            dbCaller.setSubscriptionStatus(msg.message.chat.id, command[1], true)
                .then(res => {
                    api.editMessageReplyMarkup({
                        chat_id: msg.message.chat.id,
                        message_id: msg.message.message_id,
                        reply_markup: JSON.stringify({
                            inline_keyboard: [
                                [
                                    {
                                        text: '–û—Ç–ø–∏—Å–∞—Ç—å—Å—è',
                                        callback_data: 'unsubscribe.' + command[1]
                                    },
                                    {
                                        text: KeyboardBuilder.getBackButtonText(),
                                        callback_data: 'go_to_menu'
                                    }
                                ]
                            ]
                        })
                    })
                        .then((result) => {
                            console.log(result)
                        })
                        .catch((err) => {
                            console.log(err)
                        });

                    api.sendMessage({
                        chat_id: msg.message.chat.id,
                        text: '–í—ã –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ —Ç–µ–º—É ' + command[1]
                    });
                })
                .catch((err) => {
                    console.log(err)
                });
            break;
        }
        case 'recommendations_tomorrow':
        case 'recommendations_weekend':
        case 'recommendations_interesting':
        case 'recommendations_today':
        case 'undefined':
        case 'recommendations_free': {
            if (!users[user_key].recommendations[command[0]].reply_markup.inline_keyboard
                || users[user_key].recommendations[command[0]].reply_markup.inline_keyboard.length == 0
                || users[user_key].recommendations[command[0]].results.length < command[1]) {
                return startFromMenu(msg.message.chat.id);
            }
            users[user_key].recommendations.reply_markup.inline_keyboard[0][0].url = _event.url;
            users[user_key].recommendations[command[0]].reply_markup.inline_keyboard[1].forEach((value, index) => {

                let showing_emoji = index == command[1] ? '‚úÖ ' : '';

                users[user_key].recommendations[command[0]].reply_markup.inline_keyboard[1][index].text = showing_emoji + ' ' + String(index + 1);
            });

            let _event = users[user_key].recommendations[command[0]].results[command[1]];
            console.log(_event);
            api.sendPhoto({
                chat_id: msg.message.chat.id,
                caption: _event.title + ' \n \n ' + _event.description,
                photo: _event.image_horizontal_url,
                reply_markup: JSON.stringify(users[user_key].recommendations[command[0]].reply_markup)
            })
                .then((result) => {
                    console.log(result)
                })
                .catch((err) => {
                    console.log(err)
                });
        }

    }
    //do stuff
});

app.listen(5000, function () {
    console.log('TG listening on port 5000!');
});

app.use(bodyParser.json());       // to support JSON-encoded bodies
app.use(bodyParser.urlencoded({     // to support URL-encoded bodies
    extended: true
}));
app.get('/events/:id', function (req, res) {
    ApiCaller.getEvents({
        id: req.params.id,
        fields: 'link,description'
    }).then(res => {
        console.log(res);
        if (res.data.length == 1) {
            let _event = res.data[0];
            dbCaller.getToNotify(_event.id)
                .then((chats) => {
                console.log(chats);
                    chats.forEach(chat => {
                        api.sendPhoto({
                            chat_id: chat.chat_id,
                            caption: _event.title + ' \n \n ' + _event.description,
                            photo: _event.image_horizontal_url,
                            reply_markup: JSON.stringify({
                                inline_keyboard: [
                                    [{text: '–ü–æ–¥—Ä–æ–±–Ω–µ–µ', url: _event.link}]
                                ]
                            })
                        })
                            .then((result) => {})
                            .catch((err) => {
                                console.log(err)
                            });

                    });
                })
                .catch((err) => {
                    console.log(err)
                })
        }
    })
        .catch((err) => {
            console.log(err)
        });
    res.json({status: true});
});
